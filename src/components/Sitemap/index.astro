---
import {
  sitemapSectionsJa as ja,
  sitemapSectionsEn as en,
  type SitemapSection,
} from "../../data/sitemapSections";
import { basename } from "path";
import type { AstroInstance, MDXInstance, MarkdownInstance } from "astro";
import Layout, { Frontmatter } from "@layouts/Layout.astro";

interface Props {
  lang: "ja" | "en";
}

interface AstroInstanceExt extends AstroInstance {
  title: string;
  sitemap?: boolean;
}

type Page =
  | MarkdownInstance<Frontmatter>
  | MDXInstance<Frontmatter>
  | AstroInstanceExt;

interface Link {
  title: string;
  url: string;
}

interface SitemapSectionWithLinks extends SitemapSection {
  links: Link[];
}

const { lang } = Astro.props;

const pages = await Astro.glob<Page>("/src/pages/**/*.{astro,md,mdx}");

const sectionsWithLinks = { ja, en }[lang].map<SitemapSectionWithLinks>(
  (section) => ({ ...section, links: [] })
);

for (const page of pages) {
  if (!page.url) {
    continue;
  }
  if (basename(page.url).startsWith("_")) {
    continue;
  }
  if ("frontmatter" in page && page.frontmatter.redirect_to) {
    continue;
  }
  const { title, sitemap } = "frontmatter" in page ? page.frontmatter : page;
  if (sitemap === false) {
    continue;
  }

  let path: string;

  switch (Astro.props.lang) {
    case "ja":
      if (page.url.startsWith("/en/")) {
        continue;
      }
      path = page.url;
      break;
    case "en":
      if (!page.url.startsWith("/en/")) {
        continue;
      }
      path = page.url.replace(/^\/en/, "");
      break;
  }

  for (const section of sectionsWithLinks) {
    let cond = false;
    if (section.patterns) {
      cond ||= section.patterns.some((pattern) => pattern.test(page.url!));
    }
    if (section.negativePatterns) {
      cond &&= !section.negativePatterns.some((pattern) => pattern.test(page.url!));
    }
    if (cond) {
      section.links.push({ title, url: page.url });
      break;
    }
  }
}
---
<Layout
  frontmatter={{
    title: {
      ja: "サイトマップ",
      en: "Sitemap",
    }[lang],
    lang,
  }}
  headings={[
    
  ]}
>
  {
    sectionsWithLinks.map((section) => {
      const Heading = `h${ section.depth }`;
      return (
        <>
          <Heading>{section.name}</Heading>
          <ul>
            {section.links.map((link) => {
              return (
                <li>
                  <a href={link.url}>{link.title}</a>
                </li>
              );
            })}
          </ul>
        </>
      );
    })
  }
</Layout>
